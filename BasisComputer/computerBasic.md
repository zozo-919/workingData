---
title: "计算机基础"
author: "Zozo"
date: 2025-08-31
draft: true
---

## 计算机基础

### 开发环境搭建
- 一个完整的嵌入式开发环境通常包含以下几个核心部分：
  - 集成开发环境 (IDE)：代码编辑、编译、调试的图形化界面。
  - 工具链 (Toolchain)：编译代码的核心工具，包括编译器、汇编器、链接器等。
  - 调试工具 (Debugger)：用于将程序烧录到芯片并进行在线调试。
  - 项目构建工具 (Builder)：用于管理编译过程（通常 IDE 已集成）。
  - 硬件驱动：调试器（如 J-Link， ST-Link）的 USB 驱动。

- **集成的IDE：Keil MDK**
- **编辑器：VScode**
- **工具链：ARM GNU Toolchain：**   ARM 官方维护的 GCC 编译器套件
    - 交叉工具链 就是将可读的源代码（C/C++、汇编），转换成单片机可读、可执行的机器码二进制文件（bin/hex），并提供分析和管理这些文件的能力
    - `aarch64-linux-gnu-gcc` 是 GNU GCC 交叉编译工具链
    ```bash
        # 安装 aarch64-linux-gnu-gcc aarch64-linux-gnu-g++
        sudo apt update
        sudo apt install gcc-aarch64-linux-gnu g++-aarch64-linux-gnu
    ```
    - 配置交叉编译工具链
    ```bash
        echo 'export PATH=$PATH:~/toolchains/gcc-arm-11.2-2022.02-x86_64-aarch64-none-linux-gnu/bin' >> ~/.bashrc
        source ~/.bashrc  # 使配置立即生效
    ``` 
- **构建工具：Makefile**
- **调试器：J-Link GDB Server**
- **VScode插件**
  - C/C++：Microsoft 官方插件，用于代码提示、跳转


### 安装 ubuntu 系统
  1. **下载ubuntu镜像**
     - [镜像下载地址](https://ubuntu.com/download/desktop)
     - 选择想要的LTS版本下载 后缀为 `.iso` 的文件就是系统的安装光盘镜像
  2. **虚拟机安装**
     - [VMWARE下载地址](https://www.vmware.com/products/desktop-hypervisor/workstation-and-fusion)
     - 第 1 步：**创建新的虚拟机**
        - 打开 VMware Workstation Player。
        - 点击 “创建新虚拟机”。
        - 新建虚拟机向导：
           - 安装程序光盘镜像文件：选择这一项，然后点击 “浏览”，找到你刚才下载的 Ubuntu .iso 文件。VMware 会自动检测到这是 Ubuntu。
        - 点击 “下一步”。
     - 第 2 步：**简易安装信息**
        - `您的姓名`：输入你喜欢的名字（如 ubuntu-user）。
        - `用户名`：这是你的登录名和终端前缀（如 user）。建议用小写字母和数字。
        - `密码`：设置一个登录密码。
        - `确认`：再次输入密码。
        - 点击 `下一步`
     - 第 3 步：**命名虚拟机和指定位置**
        - `虚拟机名称`：给你的虚拟机起个名字，如 `Ubuntu 24.04 LTS`
        - `位置`：***强烈建议修改位置！*** 默认在C盘，虚拟机会占用很大空间。请点击 `浏览`，选择一个剩余空间至少50GB以上的盘符（如D盘），并创建一个新文件夹（如 `VMware`）来存放它。
        - 点击 `下一步`
     - 第 4 步：**指定磁盘容量**
        - `最大磁盘大小`：分配给 Ubuntu 系统的硬盘空间。建议至少 50 GB。对于打算长期使用并安装很多软件的用户，可以给到 80 或 100 GB。
        - `将虚拟磁盘拆分成多个文件`：推荐选择这个选项。这样更方便将虚拟机迁移到其他电脑上。
        - `将虚拟磁盘存储为单个文件`：性能理论上有一点点提升，但大文件移动和管理不便。
        - 点击 `下一步`。
     - 第 5 步：**准备创建虚拟机**
        这里会显示你刚才所有的配置摘要。
        在点击 `完成` 之前，请务必点击 `自定义硬件...` 这是优化性能的关键步骤！
     - 第 6 步：==**自定义硬件（关键优化）**==
        - 在弹出的`硬件`窗口中，进行如下调整：
            - **内存**：
                - 根据你主机物理内存的大小分配。建议至少分配 4GB (4096 MB)。
            安全范围：不要超过主机可用内存的50% 如果你的主机是16GB内存，分配4GB-8GB是合理的
            - **处理器**：
                - 处理器数量：通常保持默认1即可。
                - 每个处理器的核心数量：根据你主机的CPU核心数分配。建议分配 2 个或更多的核心（如2, 4个）。这会让Ubuntu运行更流畅。
                - 例如，如果你的CPU是6核12线程，分配4个核心给虚拟机是非常安全的。
            - **网络适配器**：
                - 保持默认的 `NAT 模式` 即可 这样虚拟机就可以**共享主机的IP地址上网** 无需任何额外配置
            - **其他选项**：
                - USB控制器：确保USB版本为3.1或更高，以便在虚拟机中使用USB3.0设备。
                - 打印机等不需要的设备：可以选择它们，然后点击“移除”以节省资源。
                - 点击 `关闭`，然后回到上一步点击 `完成`。
     - 第 7 步：**自动安装与首次启动**
        - 至此 VMware 会自动启动虚拟机并开始安装过程 不需要做任何操作
        - 屏幕上有安装进度条 整个过程大约需要10-20分钟 取决于硬盘速度
        - 安装完成后 虚拟机会自动重启 并直接进入 Ubuntu 登录界面
        - 输入之前设置的密码 即可登录系统
  3. 优化设置
        - 安装 VMware Tools 
            - 现代版本的 Ubuntu 通常会自动安装开源版本的 VMware Tools（称为 open-vm-tools），它提供了诸如鼠标自由切换、屏幕自适应分辨率、共享文件夹等关键功能。
            - 检查是否已安装：打开终端，输入 `vmware-toolbox-cmd -v` 如果显示版本号，说明已安装。
            - 如果没有安装：在终端中手动安装也非常简单：
            ```bash
                sudo apt update
                sudo apt install open-vm-tools-desktop
            ``` 
            - 安装后，重启虚拟机以使所有功能生效。
        - **设置共享文件夹（强烈推荐）**  让你在主机和虚拟机之间轻松传输文件
            - 步骤：
                - 确保虚拟机已关机。
                - 在 VMware Player 主界面，`右键点击虚拟机` -> `管理` -> `虚拟机设置`
                - 切换到 `选项` 选项卡 -> 选择 `共享文件夹`
                - 在右边选择 `总是启用`  然后点击 `添加`
                - 按照向导，添加一个你主机上希望共享的文件夹（例如 D:\VM_Share）。
                - 启动 Ubuntu，共享文件夹通常会出现在 /mnt/hgfs/ 目录下。
        - **拍摄快照**
            - 这是虚拟机的“后悔药”功能。在系统处于纯净、稳定状态时，拍一个快照，以后无论怎么折腾，都可以一键恢复到这个状态。
            - 步骤：`确保虚拟机已关机` -> `右键点击虚拟机` -> `快照` -> `拍摄快照` -> `输入名称和描述`（如 “Clean Installation”）-> 点击`拍摄快照`
  4. **Ubuntu 的文件系统“映射”为 Windows 本地网络磁盘** 实现共享
    - 在 Ubuntu 上安装和配置 Samba 共享
      - 安装 Samba
        ```bash
            # 打开 Ubuntu 终端，输入以下命令
            sudo apt update
            sudo apt install samba
        ```
      - 配置 Samba 共享
        ```bash
            sudo nano /etc/samba/smb.conf
            # 在文件的最末尾添加以下配置段落: 
        ```
        ```ini
            [homes]
            comment = Home Directories
            browseable = yes
            read only = no
            create mask = 0700
            directory mask = 0700
            valid users = %S
        ```  
        编辑完成后，按 `Ctrl + X`，然后按 `Y`，再按 `Enter` 保存退出
      - 重启 Samba 服务使配置生效
        ```bash
            sudo service smbd restart
        ```
    - 在 Windows 上映射网络驱动器
      - 打开 `映射网络驱动器` 窗口
        - 打开 `此电脑`
        - 在顶部的菜单栏或工具栏中，找到并点击 `映射网络驱动器` 按钮。
        - 如果看不到，可以在 `此电脑` 的空白处右键，也能找到这个选项。
      - 配置映射设置
        - 驱动器：选择一个**未被占用的盘符**，例如 `Z:`
        - 文件夹：输入 Ubuntu 共享的地址，格式为：`\\<Ubuntu的IP地址>\<共享名>`
        - 共享名即用户名 如： \\192.168.1.100\myusername
        - 勾选 `使用其他凭据` ：强烈建议勾选，这样会弹出窗口让您输入在 Ubuntu 上设置的 Samba 用户名和密码，而不是用 Windows 的登录信息去尝试。
      - 完成连接
        - 点击 `完成`
        - 此时会弹出窗口要求您输入用户名和密码。
        - 用户名：您的 Ubuntu 用户名。
        - 密码：您通过 smbpasswd 命令设置的 Samba 密码。
        - 可以勾选 `记住我的凭据` 这样下次开机就不需要重新输入了。
        点击`确定` 
            


### 计算机基础
- **计算机基础知识**	
  - **计算机组成**：存储器、cpu（运算器、控制器、寄存器）、输入、输出设备
  - **软硬件工作流程**：用户 ―> 使用应用软件（qq、微信）―> 系统软件（win10、linux操作系统）―> 硬件
	- 应用软件是建立在有系统软件的基础上开发的 换言之 应用软件只能对系统程序进行调用
					
  - **cpu主频**：假如一台电脑的主频是2.3GHz  GHz即千兆赫 是十亿赫兹的单位 可理解为1秒钟进行23亿次运算
	- 主频越大 功耗越高 能力越强 当然也更耗电 
	- 如果电脑是n核的 则主频计算方式为：n*aGHz*0.8
  - **核显**：cpu内集成显卡  买电脑建议买带核显的
  - **内存**： cpu和硬盘之间交互数据是的缓冲区 提高cpu使用效率 本身是存储设备 断电丢失数据 即易失性存储设备
  - **操作系统的安装**：新硬盘 ― 分区 ― 分区格式（guid）― 快速分区 ― 安装系统
- **Windows基础操作**
  - `control + c` 	复制
  - `control + v`	粘贴
  - 复制粘贴的速度受下列因素影响：
    - **磁盘材料** 固态硬盘比机械硬盘读写速度快
    - **磁盘接口类型** 外接usb 内置 SATA、SAS  一般usb没有SATA快 但是usb方便
    - **文件数量**  相同大小的“多个文件”拷贝速度比“单个文件”拷贝慢
    - **复制粘贴的目录位置**  两块磁盘之间复制粘贴数据 比同一个磁盘上不同目录复制粘贴数据要快的多 切换读写消耗性能
  - 查询工具：Everything 找文件非常快。

  - **.dll文件**：动态链接库文件

  - 在不更改路径的情况下：
    - 64位的软件默认安装到 Program Files 文件下
    - 32位的软件默认安装到 Program Files(x86) 文件下

  - **Windows目录**：==操作系统的核心程序目录  千万不要动！！！！！！==

  - **用户目录**：操作系统支持多用户使用 会为每个用户划分操作空间

  - **下载工具**：
        迅雷工具  直接官网搜索下载就行

  - **如果忘记Windows密码**：
        物理机操作步骤：插入U启动盘 pe系统盘 重启电脑 进入bios 设置U盘启动 进入pe 修改密码即可

鲁大师工具。。。。可以下载一个  可以查看电脑的配置 性能等等

  - 开启or关闭软件的开机自启动：
    - 设置 ― > 应用 ― > 启动

  - ==**??文件共享：**==
    1. 网络工具： qq、wx、百度网盘等。  用于距离很远且处于不同网络时的首选项
    2. 物理工具： U盘、移动硬盘等
    3. Windows文件共享 同一网络 比如都在同一办公室
        - 在电脑上将某个文件设置为共享文件  然后别人通过 `Windows + R` 输入 `\\192.163.1.114\filename`  这种ip地址+文件名就可访问文件夹了
        - `Windows + R` 输入`cmd` 进入命令终端  输入`ipconfig` 查看电脑的ip地址
    4. 本地文件共享软件：feiq等

  - 虚拟机的快照：记录当前系统的软硬件配置

### Linux操作系统
- **Linux操作系统**
  - **目录介绍**：
    - `bin 目录`：	存放一些二进制可执行文件 即一些命令文件 如ls、cd、cp 等一些操作系统的指令  这些指令都是通过一段代码来实现的
    - `boot 目录`：	存放一些开机操作系统就加载的配置文件、系统启动的必要文件
    - `dev 目录`：	硬件设备的控制文件  用于系统加载硬件
    - `etc 目录`：	系统及安装的软件的配置文件 类似Windows的注册表 安装软件时 其配置文件 默认就下载到该目录
    - `home 目录`：	存放所有普通用户的目录 类似Windows的用户目录
    - `root 目录`：	超级管理员
    - `lib 目录`：	存放库文件 32位软件默认的安装在此 一般以“so”结尾的库文件 类似Windows的Program(x86) 目录  里面存放的一些dll动态链接库文件  
    - `lib64 目录`：	64位软件默认的安装位置 存放库文件 同lib
    - `proc 目录`： 	即process 进程  每个进程编号的目录 可通过 “ps -ef” 指令查看进程编号 类似Windows下任务管理器下的进程
    - `run 目录`：	程序运行过程中产生的临时文件 系统不会自动清除
    - `tmp 目录`：	存放临时文件 当某个文件长时间没有使用 系统会自动清除
    - `sbin 目录`：	超级用户才能使用的命令 如shutdown(关机)、reboot(重启)指令
    - `sys 目录`：	系统功能目录
    - `usr 目录`：	用户级目录 存放一些软件程序及这些程序所需要使用的库 也会保存一些程序需要的资源文件 该文件与/根 目录很像
    - `var 目录`：	存放一些变动文件 如日志文件、网页文件、缓存等
    -----------------==**以上目录都很重要 不能删除**==---------------------------
    - `media 目录`：多媒体文件 如音乐文件、视频文件、ppt文件  不重要
    - `mnt 目录`：	用于挂载光盘、u盘 即插入u盘 打开之后一般在该目录下  不重要 
    - `opt目录`：	一些软件安装的默认存储目录 不太重要 
    - `srv目录`：	用来存放项目源代码 不重要

  - **相对路径**：从当前所在目录开始数等不完整路径
  - **绝对路径**：从根目录开始数等完整路径

  - **内存的物理机制**：
	- 数据引脚  地址引脚 
	- 在内存中 每字节的数据 都得有对应的地址
  - CPU往内存中**写入1字节数据**步骤：
	- cpu通过内存总线 1.将地址传入地址引脚来指定地址  2.从数据引脚输入我们的数据  3.将控制信号的WR控制为1
  - **读数据**：
	- cpu通过内存总线 1.将地址传入地址引脚来指定地址    2.将控制信号的RD控制为1   3.从数据引脚读出我们的数据输入到总线去

  - 内存可以存储的数据量
	- 假设有10个地址引脚 则可以表达的地址是 **2^10^** 个 每个地址可以存储一个字节的数据 那么总大小就是 `1024*1 = 1024` 字节 也就是`1KB`
	- 如何提高内存容量？
    	- 将地址引脚数增加 比如增加到32。则内存容量就是 **2^32^ * 1 = 4GB**

  - **指针、引用本质上就是内存地址**  有了内存地址就可以操作对应的内存数据了

  - 字节序：
	- 字节顺序**从低地址到高地址**顺序存储称为 ==大端序==
	- 字节顺序**从高地址到低地址**顺序存储称为 ==小端序==

  - **程序运行的过程：**
  	- cpu根据程序的步骤 对相应的数据进行计算处理的过程

  - **CPU的执行过程**
	- CPU也是一个集成电路  它是根据指令进行各种处理的电子电路
	- 每个指令背后 都对应着相应的电子电路的工作
	- CPU工作流程
	```mermaid
    flowchart TD
        A[读取指令<br>Fetch] --> B[解码指令<br>Decode]
        B --> C[执行指令<br>Execute]
        C --> D[写回结果<br>Writeback]
        D --> A
    ```
    **CPU指令周期**
    ```mermaid
    flowchart TD
        A["开始指令周期"] --> B[阶段一: 读取指令]

        subgraph B[阶段一: 读取指令]
            direction LR
            B1[PC -> MAR:内存地址寄存器] --> B2[MAR -> 地址总线] --> B3[内存返回IR:指令寄存器] --> B4[PC + 1 -> PC]
        end

        B --> C[阶段二: 解码指令]
        subgraph C[阶段二: 解码指令]
            direction LR
            C1[IR -> 指令解码器] --> C2[解读操作码/操作数] --> C3[生成控制信号]
        end

        C --> D[阶段三: 执行指令]
        subgraph D[阶段三: 执行指令]
            direction TB
            D1{指令类型?}
            D1 -- 算术/逻辑 --> D2[ALU执行运算]
            D1 -- 内存访问 --> D3[计算有效地址]
            D1 -- 控制流 --> D4[计算目标地址]
        end

        D --> E[阶段四: 写回结果]
        subgraph E[阶段四: 写回结果]
            direction LR
            E1{目标?}
            E1 -- 寄存器 --> E2[结果 -> 寄存器]
            E1 -- 内存 --> E3[结果 -> 数据总线 -> 内存]
        end

        E --> F["指令周期结束"]
        F --> A
    ```  

    - **寄存器：**
    	- 用来暂存指令、数据等处理对象 可以将其看成内存的一种 一个cpu的内部一般有20～100个寄存器  访问寄存器比访问内存要快的多
	- **控制器：**
		- 负责把内存中的指令、数据读入寄存器中 并根据指令的执行结果来控制整个计算机
	- **运算器：**
		- 负责运算从内存中读入寄存器的数据

    - **cpu执行流程：**     ==**读取 ― 解码 ― 执行**==
      - 读取：
        - cpu从内存读取指令 并返回指令（机器语言）
      - 解码：
        - 将机器语言 翻译成 确定要执行的操作
      - 执行：
        - 执行实际的操作

    - **程序计数器PC：（一种寄存器）**
		- 指向下一条要执行的指令的内存地址

	- IP寄存器就是指令指针寄存器 功能也就是??同PC
		- 在32位计算机 简称eip    64位计算机 就是rip

	- cpu指令集：
		- 不同架构的cpu的指令集不同  不同架构的cpu中 名字相同的指令 含义也不一定相同
		- 查看cpu架构：
				windows下的指令：`systeminfo`
				Linux下的指令：`lscpu`
	- **指令**：
		- **操作码 + 操作数**
		- **寄存器rbp和rsp**：
			- rbp ：栈基址寄存器（栈帧指针） ，指向当前栈帧的栈底地址
				- 栈帧：存储参数值、局部变量、返回地址
			- rsp ：栈顶寄存器（栈指针），指向栈顶元素
		- **函数调用栈：**
			- 执行程序时 操作系统会分配一段栈内存 用于作为函数调用栈的功能
			- 在内存中 函数调用栈一半是倒着的 栈底位于高地址 栈顶位于低地址
		- **操作系统的作用：**
			- 应用程序不可直接访问硬件资源 操作系统 对上：为应用程序提供抽象的接口 对下：硬件资源由操作系统统一管理
			- 操作系统的启动流程：
    			- 预备知识：操作系统本质上是软件，程序  
        			1. 操作系统程序事先存放在磁盘中  
        			2. Bootloader ：将磁盘中的os加载到内存  
        			3. BIOS 提供开机支持工作 固定在主板的ROM区域 （rom只读寄存器）
    			- 首先，计算机启动后 主板有电了 cpu也开始执行指令 
        			1. cpu执行主板上ROM区域的BIOS的指令 （自检和加载Bootloader程序到内存）
        			2. cpu开始执行存放在内存中的bootloader指令 
        			3. Bootloader程序将OS程序和数据加载到内存   
        			4. Cpu跳到OS程序指令在内存中的位置 执行OS程序   
        			5. 开始操作系统的初始化工作 创建各种应用程序 操作系统启动完毕
		- **内核态 VS 用户态**
			- 用户态：应用程序在运行时 cpu所处的状态    **cpu不能执行部分指令 如特权指令**
			- 内核态：操作系统在运行时 cpu所处的状态    **cpu可执行任何一条指令**
		- **CPU和I/O交互**：
			- 设备控制器：
				- 包括命令寄存器、数据寄存器、状态寄存器
			- 端口映射I/O : 将每个设备控制器的寄存器标志为不同的端口            ==（即独立编址）==
			- 内存映射I/O : 将每个I/O设备的各个寄存器都编址 看成“内存地址”      ==（即统一编址）==
		- **中断机制：响应请求**
		- **DMA机制 减少cpu开销**
		- **DMA控制器：**
			- 包括数据源地址、数据目的地址、数据长度地址
			- 各个设备有配套的DMA控制器 DMA参与数据移动 一次打印任务只需要一次中断
  - **主存（内存）**
	- 计算机主存 也称物理内存 内存可看成由若干个连续字节大小的单元组成的数组 每个字节都有一个唯一的物理地址 cpu访问内存前 先拿到内存地址 然后通过内存地址访问内存中数据指令
	- **物理寻址**：
		类似根据索引访问数组元素一样   cpu访问内存的时间复杂度: O(1)
	- **总线分工**：
		- **数据总线**：
			- 负责传输实际数据
			- 数据总线的位数：
				数据总线位数  ―>  寄存器位数  ―> cpu位数 （32或64）
				数据总线为32 ：一次性可以传输32位数据（即4个字节）
		- **地址总线**：
			- 负责传输数据地址 用来确定到底把数据传输到哪里去 是内存的某个位置 还是某个I/O设备
			- 地址总线位数 ―> 内存地址信号引脚数量 
		- **控制总线**：
			- 负责传输控制信号 用于控制对于总线的访问

	- **寻址能力**：
		- 假设 cpu的位数位16  地址总线为20  则其寻址能力为 2^16^=64KB  地址数量为2^20^=1MB
		- 那么cpu只能访问64kb的地址 剩下的地址怎么半呢？ 那么这里用到段基址寄存器和IP
			- 把1MB的内存 按照64KB分为一个段
				- **段基址寄存器**：一个段在内存中的基地址
				- **IP**：存储下一条需要执行的指令在段中的偏移量
				- **16位cpu寻址20位内存**：
					- 段基址左移4位 + ip
 

- **Linux基础命令**：
    - **用户操作**：
        ```bash 
            # 添加一个名为username的用户
            useradd username 	  
            
            # 为username用户设置密码
            passwd username 
            
            # 查看username用户是否存在
            id username

            # 删除名为username的用户  ?? 删除用户后 基于该用户所创建的目录还在
            userdel username

            # 删除名为username的用户及其关联文件 
            userdel -r username

            # 锁定名为username的用户
            usermod -L username

            # 查看名为username的用户的当前状态
            lchage -l username

            # 将名为username的用户的解除锁定
            usermod -U username
        ```

    - **用户组操作**：    `/etc/group` 用户组信息存放在此
        ```bash
            # 在名为user的用户组下创建一个username用户
            useradd -g user username
            
            # 删除名为user的组
            groupdel user

            # 将user1组名改为user0
            groupmod -n user0 user1

            # 将名为user1的用户 添加到user0组
            usermod -G user0 user1

            # 将user1用户 所属主组改为user0
            usermod -g user0 user1
        ```
    
    - 用户信息都存放在 `/etc/passwd`    密码存放在 `/etc/shadow`

  - 格式：`[用户名@主机名 所在目录] `   
    ```bash
        hostname		# 查看当前主机名
        hostname  xxx	# 修改主机名
        logout			# 退出登录
        hostnamectl		# 查看当前主机的信息

        reboot 			# 重启系统
        shutdown 		# 关机 默认5秒钟后关机
        shutdown -h now # 立即关机
        shutdown -h 5	# 5分钟后关机
        shutdown -r 5	# 5分钟后重启系统
        shutdown -c		#取消相关上列shutdown操作
        
        w 		# 查看用户登录状态
        exit 	# 退出当前用户登录
    ```
  - 权限管理：	**root用户权限最高**
    - chmod指令的使用

    `echo $PATH` 查看当前环境变量

    - **文件类型**：	
        `-` 文件
        `d` 目录
        `l` 软链接（相当于Windows的快捷方式）
        `b` 块设备 （ls /dev ，可以看到硬盘sda等）

    - 查看selinux是否开启： `sestatus  #一种NSA的安全子系统 开启的话 linux使用起来可能不太方便 建议关闭`								
      - 关闭方法：首先需要root权限
        ```bash  
            ls -l /etc/selinux/config
            vi /etc/selinux/config
            
            # 把7行改为：
            SELINUX=disable    #然后保存退出 并且重启系统才会生效
        ```

    - 查看文件的三种时间：`stat filename`

  - **shell命令行快捷键**：
    `ctrl + a`		光标跳转至正在输入的命令行首部
    `ctrl + e` 		光标跳转至正在输入的命令行尾部
    `ctrl + c`		终止前台运行的程序 用于打断一些操作
    `ctrl + d`		退出shell
    `ctrl + z`		将任务暂停 挂至后台 执行fg命令继续运行
    `ctrl + l`		清屏 和clear命令等效
    `ctrl + k`		删除从光标到行末的所有字符
    `ctrl + u`		删除从光标到行首的所有字符
    `ctrl + r`		搜索历史命令 利用关键字搜索
    `ctrl + w`		光标往前删除一个参数 以空格为分割

  - **vim快捷键**：
    `set number`		显示行号
    `h、j、 k、 l`		移动光标 上下左右
    `i、a、o`			进入编辑模式
    `ctrl + f`			下翻一页
    `ctrl + b`			上翻一页
    `ctrl + d`			下翻半页
    `ctrl + u`			上翻半页
    `0`				跳至行首 跳到第0个字符
    `^`				跳至行首的第一个字符（shift + 6）
    `$`				跳至行尾（shift + 4）
    `gg`				跳至文首
    `G`				跳至文尾
    `5gg/5G`			跳至第5行	或者命令行模式 ：5 也是跳至第五行
    `x`				删除单个字符
    `10x`				删除10个字符
    `dd`				删除光标所在行
    `6dd`				从光标开始往下删除6行
    `p`				粘贴内容到当前行下面
    `P`				粘贴内容到当前行上面
    `yy`				复制行
    `5yy`				复制5行
    `u`				撤销操作
    `/pattern`			向后搜索字符串pattern  # n向下 N向上 查找
    `？pattern`		向前搜索字符串pattern  

    `：1369s/shell/Jaden/g`			将1369行的shell替换为Jaden    或`：1369@shell@Jaden@g`  或 `：1369#shell#Jaden#g`
    `：1369，1379s/shell/Jaden/g`	将1369行～1379行中的 shell 替换为 Jaden
    `：1369，$s/shell/Jaden/g`		将1369行～文末中的 shell 替换为 Jaden
    `：%s/old/new/g	`				搜索整个文件 将所有 old 替换为 new
    `：%s/old/new/gc`				搜索整个文件 替换old 为 new  每一次替换需要 y 确认替换 或 n不替换 a全部替换

  - Linux输入输出重定向：
    `echo 123 > 1.txt`				将123 写入1.txt文件中  ?? 在重定向中 会先把1.txt中的东西清空
    `echo 123 > 1.txt`				追加输出 不会清空原本的东西
    `>b.txt`						清空b.txt文件

  - 文件传输：
    - scp传输：
        - **本地推送至远程**：
            格式  `scp 本地文件路径 远程主机用户@远程主机ip地址 : 远程主机某个目录`
                        `scp /home/zozo/filename  Zozo@193.168.1.123:/home/yoyo/yofile`
        - **远程拷贝到本机**：
            格式  `scp 远程主机用户@远程主机ip地址：远程主机某个文件 本地路径`
                    `scp Zozo@196.168.1.231:/home/zozofile . `

  - find文件查找：
    ```bash
        find  /etc  -maxdepth 1 -type f -name  “*pa*”
        #命令  目录   查找深度   类型           文件名称包含
    ```

 - Linux 进程：
    ```bash
        ps      # 查看进程
        ps -ef  # 查看进程
        top     # 查看实时进程资源占用情况  类似windows下的任务管理器的进程
        pstree  # 查看进程的树形结构
        kill pid      # 结束进程号为pid的进程
        pkill cid     # 批量结束进程名称为cid的进程 ??慎用
        kill -9 pid   # 强制结束进程 系统不会自动释放资源 可能导致资源无法释放 ??慎用
    ```

  - 查看计算机硬件信息：
    ```bash
        lscpu 	    # 查看cpu
        free -h     # 查看内存命令
        df -h	    # 查看硬盘命令
        date      	# 查看时间
        date +%F    # 查看年月日
        systemctl restart chronyd 	# 同步时间
        crontab -l 		            # 查看当前计算机的定时任务
        tail -f filename 		    # 检测文件尾部内容发生的变化
        systemctl stop firewalld 	# 关闭防火墙
        systemctl disable firewalld # 关闭防火墙
        echo $val 	# 查看名为val的环境变量的值
    ```

  - 正则表达式：
    `^`  搜索以……开头的数据
        eg：`grep ‘^#’ text.txt`    找出以#开头的行数据
            `grep -v ‘^#’ text.txt`  找出不是以#开头的行数据。 -v表示取反
    `$` 搜索以……结尾的数据
        eg：`grep ‘op$’ text.txt`	找出以op结尾的行数据
    `^$` 表示空行 
        eg：`grep ‘^$’ test.txt`		找出所有的空白行
            `sed ‘/^$/d’ test.txt`	删除空行 加-I参数 就修改了原文件
    `.` 表示任意一个字符
        eg：`grep ‘.op’ text.txt`		查找xop 此处x为任意的一个字符
    `\` 转义字符 还原原始字符的意义
        eg：`grep ‘\.op’ test.txt` 	查找含有.op的数据行

    `.*` 匹配任意字符 并重复0次或者多次
    
    `[a-z]` 匹配a到z中任意一个字符
    `[a,z]` 匹配a或z中任意一个字符
    `[^abc]` 匹配不包括a或b或c的项
    ```bash
        grep [^0-9] text.txt    # 不要数字    -o只显示匹配结果
        grep [^a-z] text.txt	# 不要小写字母
        grep [^A-Z] text.txt	# 不要大写字母
        grep [^0-9a-zA-Z] text.txt  不要数字大小写字母
    ```

  - `su` 切换用户
  - `sudo` 超级管理员权限

  - VMWARE的三种模式：
    - 仅主机模式   ― 仅用于虚拟机与主机之间的通信 虚拟机无法上网
      - 桥接模式	― 基于物理机的网卡上网 交换机会为虚拟机分配与物理机处于同一网段的IP
      - NAT模式		― 相当于虚拟机创建了一个局域网 与物理机不属于同一网段  当虚拟机要上网时 局域网通过NAT转换成物理机的IP上网 物理机充当路由
    
      - 重启网络服务：systemctl restart network

  - 虚拟机上不了网的思路：
    - 查看虚拟机网卡是否开启  检查DHCP 或NAT服务是否开启   检查IP是否重复
    - ping网址能通 ping域名不能通 可能是DNS中配置的IP错了
  - 物理机上不了网：
    - 检查物理连接是否正常  ping网关  ping公网IP  `ping www.baidu.com`  ping自己的服务器


### GCC 编译器

### 进制转换

### 原码、反码、补码

### 数据存储原理

