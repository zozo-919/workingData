### 公司：能点EPT
#### 面试时间：2025年10月16日 周四 下午15:00
#### 面试地点：深圳龙华区宝能科技园（11号门）
#### 公司产品 光电液位传感器
- 食品级小流量计（Food-Grade Flowmeter）
- 光电式液位开关（Optoelectronic Level Controller）
- 光电式运动传感器（Optoelectronic Motion Sensor）
- 光电式防倾倒开关（Optoelectronic Toppling Preventing Switch）
- 光电位置开关（Optoelectronic Position Switch）
- 光电液位传感器



#### ARM Cortex-M 内核与 STM32 基础
- **ARM Cortex-M 内核**
  - 说说你熟悉的ARM Cortex-M系列内核
    我比较熟悉的ARM Cortex-M系列内核主要是M4，它基于ARMv7E-M架构。
  - Cortex-M系列的异常/中断机制是怎样的？什么是NVIC？
    Cortex-M的异常和中断是一种硬件自动化的快速响应机制，所有异常（包括中断）都有一个唯一的编号，对应一个存储在异常向量表（位于Flash起始地址）中的函数指针，当异常发生时，硬件会自动：
    暂停当前程序。
    根据编号查找向量表，直接跳转到对应的异常服务程序 执行。
    执行完毕后，再自动恢复现场，继续执行原程序。
    NVIC（嵌套向量中断控制器） 是集成在Cortex-M内核内部的一个硬件单元，是整个中断机制的管理和指挥中心。它的核心职责是：
        管理优先级：为每个中断源配置优先级，决定谁先被处理。
        允许嵌套：高优先级中断可以打断正在执行的低优先级中断。
        快速响应：自动处理跳转和现场保护，无需软件干预，延迟极短。
    总结： 异常/中断机制是CPU响应事件的流程，而NVIC是管理和执行这个流程的核心硬件。两者配合，确保了嵌入式系统的实时性和可靠性。
  - 什么是SysTick？它有什么作用？
    SysTick是一个集成在ARM Cortex-M内核内部的24位递减计数器。它被称为系统定时器，其核心作用是为操作系统（或任何系统）提供一个周期性的、不受用户应用干扰的“心跳”时钟基准。
    工作原理简述：
        SysTick被配置为一个特定的重载值（比如，当系统时钟为72MHz时，设置重载值为72000）。
        计数器从该值开始，每个时钟周期递减1。
        当计数器减到0时，会触发一个SysTick异常（中断），同时计数器会自动重载该值并重新开始递减。
        如此周而复始，产生固定时间间隔的中断。
  - 上电后，Cortex-M内核的第一条指令从哪里获取？（考察点：启动流程，向量表中的复位向量）
    Cortex-M内核上电后，从异常向量表的第一个表项――复位向量中获取地址，并从该地址处执行第一条指令。
- **STM32 特定知识**
  - STM32的启动文件（startup_stm32fxxx.s）主要做了哪些事情？（考察点：初始化堆栈指针、设置PC指针、初始化.data段和.bss段、调用main函数）
    1. 初始化栈指针
    动作： 从向量表的第一个表项（0x00000000）加载主栈指针（MSP）的初始值（_estack）。
    作用： 为后续函数调用、中断服务程序提供栈空间。这是C程序能够运行的基础。
    2. 初始化程序计数器
    动作： 从向量表的第二个表项（0x00000004）获取复位向量（Reset_Handler的地址），并跳转到该地址执行。
    作用： 这是CPU执行的第一条指令的源头。
    3. 设置中断向量表
    动作： 在Flash的起始部分定义了一个所有异常和中断服务程序入口地址的数组（即中断向量表）。
    作用： 当发生中断或异常时，CPU能自动查找这个表并跳转到对应的处理函数。
    4. 初始化数据段（.data）
    问题： 已初始化的全局变量和静态变量（如 int a = 100;）的初始值存储在Flash中，但运行时它们需要存在于可读写的RAM中。
    动作：
    从Flash中的加载地址（sidata）拷贝这些变量的初始值。
    粘贴到RAM中的运行地址（sdata）。
    作用： 确保所有初始化变量在main()函数开始前就拥有正确的初始值。
    5. 清零未初始化数据段（.bss）
    问题： 未初始化或显式初始化为0的全局/静态变量（如 int b; 或 int c = 0;）位于.bss段。
    动作： 将整个.bss段（从sbss到ebss）的内存全部清零。
    作用： 符合C语言标准，确保这些变量从0开始。
    6. 配置系统时钟
    动作： 跳转到SystemInit函数（通常由HAL库或标准外设库提供）。这个函数会配置PLL、时钟树，将系统时钟（SYSCLK）提升到芯片运行的最高频率（如72MHz, 168MHz）。
    作用： 让芯片运行在预设的性能状态。
    7. 跳转到主程序
    动作： 调用C库的__main函数。__main会完成C运行时环境的一些初始化，最终调用用户编写的main()函数。
    作用： 将执行权交给用户的应用程序。
    8. 提供默认的中断服务程序
    动作： 为所有中断向量预先定义一个默认的（通常是无限循环的）中断服务程序（IRQ Handler）。
    作用： 防止因意外中断或未编写处理函数而导致程序跑飞。当你用CubeMX配置外设中断时，它会帮你覆盖这个弱符号定义，指向你生成的函数。

  - STM32的时钟树你了解吗？请简要描述一下从晶振到系统时钟（SYSCLK）的路径。（高频问题，考察对HSE, HSI, PLL等的理解）
  - STM32有几种低功耗模式？请举例说明其应用场景。（考察点：Sleep, Stop, Standby模式）
  - 你使用过STM32的哪些开发工具？IAR, Keil，还是STM32CubeIDE？你对STM32CubeMX和HAL库/LL库怎么看？（考察点：工具链熟悉度，对硬件抽象层的理解）
- **外设接口协议与调试（SPI, I2C, USB）**
  - SPI
    - 请简述SPI协议的基本原理和通信过程。
    基本原理：SPI（Serial Peripheral Interface）是一种高速、全双工、同步的串行通信总线。它采用 “一主多从” 的架构，通信总是由主设备（Master）发起，它的核心设计是通过4根线，以移位寄存器的方式实现数据交换。
    通信过程：
        起始信号：
        主设备通过拉低从设备选择（CS/SS） 信号线来选择要通信的从设备。
        数据传输：
        主设备产生时钟信号（SCLK）。
        在时钟信号的每个周期内，完成一次全双工的数据传输：
        主设备通过 MOSI 线输出1位数据。
        从设备通过 MISO 线输出1位数据。
        数据在时钟的边沿 被采样。具体在上升沿还是下降沿采样，由时钟极性（CPOL）和时钟相位（CPHA）配置决定。
        结束信号：
        通信完成后，主设备拉高 CS/SS 信号线，结束本次通信。

    - SPI有哪几种工作模式？由什么信号决定？（高频问题，考察CPOL和CPHA的理解）
    SPI有 4种 工作模式。它们由时钟极信和时钟相位两个信号决定，时钟极性决定sclk时钟信号在空闲状态的电平，相位极性决定数据在哪个边沿被采样（cpha =0，第一个； cpha= 1，第二个）
    - SPI是全双工还是半双工？为什么？
        全双工，同时收发数据。
    - SPI和I2C相比，优缺点各是什么？
        spi高速全双工，i2c仅需两根信号线，SPI需要四根信号线，i2c低速，协议复杂
    - 在调试SPI时，如果通信失败，你的排查思路是什么？（经典调试问题）
        检查基础硬件，进行配置核对，抓波形分析。
    - 你如何配置STM32的SPI为主机和从机？需要注意什么？
        主机的话，就负责发起信号，提供sclk，配置时钟信号，控制从设备片选引脚，主动发送/接收消息；
        从机等待响应，检测自身的nss引脚电平。
    - 遇到过SPI通信速度过快导致数据出错的情况吗？你是如何解决的？（考察点：信号完整性、PCB布线、上下拉电阻、时钟降频）
  - I2C
    - 请描述I2C协议的起始信号、停止信号、数据有效和ACK/NACK信号。
        SCL高，SDA从高到低是起始；SCL高，SDA从低到高是停止；数据在SCL低时变，高时稳；ACK是接收方在第9个时钟把SDA拉低
    - I2C总线的上拉电阻为什么是必须的？如何选择阻值？
      上拉电阻是为开漏输出的I2C总线提供高电平的唯一途径。
      I2C设备内部的输出级电路，只能将SDA和SCL线主动拉低（通过MOS管或三极管接地），而无法主动输出高电平。
    - 什么是I2C的“时钟拉伸”？
    - 调试I2C时，最常见的问题是什么？如何解决？（经典调试问题）
      抓波形
    - 如果I2C总线上有多个从设备，其中一个设备故障导致整个总线拉低（总线锁死），你如何恢复？（进阶问题，考察对I2C电气特性的理解，解决方法：发送多个时钟脉冲直到该设备释放数据线）
    - 如何用软件模拟一个I2C主机？写出起始和发送一个字节的伪代码。
  - USB
    - USB有哪几种传输类型？各自适用于什么场景？（控制传输、中断传输、批量传输、等时传输）
        控制传输（枚举、设备命令）、中断传输（键盘、鼠标）、批量传输（U盘、打印机）、等时传输（摄像头、扬声器）
    - 请描述USB设备的枚举过程。
    - 什么是USB描述符？你了解哪些重要的描述符？（设备描述符、配置描述符、接口描述符、端点描述符）
      USB描述符是一些标准化的数据结构，里面包含了USB设备的所有属性、配置和功能信息。相当于设备的身份证，当设备插入主机后，主机就会通过枚举过程来读取这些描述符。最重要的有设备描述符（全局信息）、配置描述符（电源和接口集合）、接口描述符（核心功能定义）、端点描述符（数据通道属性），以及对于HID设备特有的HID报告描述符（数据格式定义）。主机通过层层解析这些描述符，最终识别并正确驱动USB设备。
    - 你使用过STM32的哪个USB IP？是Device， Host还是OTG？
    - 你基于什么库或栈来开发USB功能？是STM32的HAL库，CubeMX生成的代码，还是其他第三方栈？
    - 当电脑无法识别你的USB设备时，你的调试步骤是什么？
    - 你实现过什么类型的USB设备？HID， CDC（虚拟串口），还是MSC？
    - 什么是内存对齐？为什么在ARM架构中需要注意内存对齐？
      触发硬件异常，导致程序崩溃，性能差
    - const关键字在修饰指针时的不同位置，分别代表什么含义？
    - STM32的内存架构是怎样的？（Flash, RAM的分布）
      地址统一编址但物理上分离。flash存放代码和常量，sram存放运行时数据、堆栈；外设区通过读写寄存器来控制硬件；内核外设区配置内核本身。
    - 栈和堆在嵌入式系统中位于哪里？如何设置栈大小？栈溢出会导致什么后果？
      栈和堆都位于RAM中，栈从高地址向下增长，堆从低地址向上增长。栈大小在链接脚本中设置，可以通过静态分析和填充魔数的实践方法来估算。栈溢出的后果非常严重，主要是破坏关键数据或导致程序跑飞，且难以调试。因此在资源受限的嵌入式系统中，合理设置并监控栈大小至关重要。
    - 你遇到过内存泄漏的问题吗？在资源受限的MCU上如何排查？
    - 什么是看门狗？你如何使用独立看门狗和窗口看门狗？
      看门狗本质上是一个独立的计数器，或者说是一个硬件定时器。它的唯一任务就是防止软件进入死循环、跑飞或卡死在某个状态
    - 如果给你一块全新的STM32芯片，让你点灯一个LED，你需要做哪些步骤？   
      选择一个合适的gpio引脚 ， 配置时钟，进行系统初始化，配置外设驱动，gpio引脚，实现业务逻辑代码，编译烧录。

#### 从0搭建嵌入式系统平台
- **需求分析与平台选型**
  1. 明确需求：
    - 功能 ： 系统需要完成的任务？（采集传感器、显示界面、连接网络、控制电机）
    - 性能 ： 对处理速度、实时性要求？
    - 功耗 ： 电池供电or常电？
    - 成本 ： bom成本
    - 外设接口 ： 需要哪些接口？（usb、uart、I2c、spi、adc等）
    - 显示 ： 需要什么屏幕？什么尺寸和分辨率
  2. 选择核心硬件
    - 微控制器MCU/微处理器MPU
      - MCU：适合**控制密集型**任务、功耗低、成本低。常见系列 stm32、esp32、gd32
      - MPU：适合**计算密集型**任务、可运行Linux等复杂操作系统。常见系列 树莓派等 
- **硬件平台准备**
  - 开发板、焊接工具、万用表、逻辑分析仪、示波器、杜邦线、外围模块等等
- **软件开发环境搭建**
  1. 安装集成开发环境
    - 对于MCU（无操作系统or FreeRTOS）：
      -  以stm32为例 ：安装`stm32cubeIDE`（集成了编译器、调试器和stm32cubeMX配置工具）
      -  通用arm：如`keil MDK` 或`IAR` 或使用开源`gcc ARM Embedded + vscode`
    - 对于MPU（运行Linux）：
      - 在PC上（通常是Linux系统）上安装交叉编译工具链。
  2. 安装配置工具
    - stm32cubeMX：用于图形化配置STM32的引脚、时钟、外设和中间件，并生成初始化代码
    - 芯片厂商的配置工具。（应该就是君正的`Iconfig`工具）
  4. 安装调试驱动 
    - 开发板自带的调试器（J-Link等）  
- **系统构建与移植**
  1. **对于MCU：**
    - 创建裸机工程
      - 使用IDE或配置工具生成一个基础“blinky“工程，让led闪烁。这就是所谓的“hello word”
      - 理解生成的代码结构 尤其是启动文件、主循环、外设初始化。
    - 移植/集成实时操作系统
      - 如果应用复杂 则需要多任务管理 此时需要引入rtos
    - 编写硬件驱动
      - 对于简单的板上外设（如gpio、uart），厂商hal库已经提供
      - 对于外部模块（如I2C传感器、spi屏幕）、则需要根据datatsheet 调用hal库或直接操作寄存器来编写驱动代码
  2. **对于MPU：** 
    - 构建bootloader：
      - Bootloader是芯片上电后运行的第一段代码 负责初始化最基本的环境 并加载操作系统
      - 最常用的是U-Boot 需要为特定的板子配置和编译U-Boot
    - 构建Linux内核：
      - 从 kernel.org下载内核源码 或使用芯片厂提供的定制版内核
      - 用配置工具为板子配置内核，启动所需要的外设驱动、文件系统支持等
      - 使用交叉编译工具链编译内核，生成一个镜像文件
    - 构建根文件系统：
      - 根文件系统包括操作系统运行所需的库、应用程序和配置文件
    - 烧录系统： 
      - 将编译好的bootloader、内核镜像和设备树、根文件系统烧录到开发板的存储设备（nand flash等）
- 应用开发与调试
  - 应用程序开发
    - MCU：在IDE中编写业务逻辑代码 通常是在main.c循环中或创建多个rtos任务
    - MPU：在Pc上使用交叉编译工具链来编译程序 然后烧录到开发板
  - 测试与调试
    - printf调试
    - led调试
    - 仿真器调试
    - 逻辑分析仪调试

#### bootloader
- **什么是bootloader？为什么是必须的？**
  bootloader是一段在操作系统内核运行前执行的一段代码，其核心任务就是完成硬件的初始化，为运行操作系统准备好环境，然后加载并启动操作系统内核
  芯片上电后是一个空白状态，时钟、内存、存储控制器等硬件都未初始化，无法直接运行操作系统，所以需要一个轻量级的程序来完成这些准备工作。
- **简述一个bootloader的启动流程**
  - 一般bootloader分为两到三个阶段
    - 第一阶段：通常用汇编，进行CPU核心初始化（如设置异常向量表、关闭看门狗、设置栈指针、初始化系统时钟等）、初始化内存控制器，然后将下阶段要用到的代码复制到内存，并进行跳转
    - 第二阶段：通常是C语言，进行更复杂的硬件初始化、提供命令行接口、加载操作系统内核镜像到内存，最后传递参数并跳转至内核
-** bootloader为什么要分多个阶段？**
  - 芯片内部的SRAM或ROM非常有限，无法容纳功能完整的bootloader
  - 在第一阶段的任务就是创造一个能运行c代码、并且有足够内存的最小环境，只有在第一阶段初始化好ddr后，才能将更强大的、功能更全的U-boot加载到内存中运行。
- **在bootloader的第一阶段，为什么要用汇编语言？主要做哪些事？**
  - 此时C语言运行环境尚未建立，需要最底层的指令直接控制CPU
  - 主要做的事情：设置异常向量表、进入特定模式，关闭看门狗、关闭中断、设置系统时钟、初始化内存控制器、设置栈指针、代码重定位、清除BSS段、跳转到C入口函数 
- **代码重定位是什么？为什么需要？**
  - 将bootloader自身从当前存储地址（如慢速的Flash）复制到它的链接地址（快速的DDR）的过程
  - 在flash中直接运行代码 速度慢 Stage1起初是作为位置无关码运行的，但其链接地址是DDR。在跳转到DDR中的代码之前，必须先把代码复制到DDR的链接地址处，否则后续绝对地址寻址会出错。
- **在跳转到内核之前，Bootloader需要为内核准备哪些信息？**
  - 机器ID：告诉内核它正在哪种机器上运行
  - 设备树：将一个描述硬件拓扑结构的设备树二进制文件的地址传递给内核
  - 启动参数：命令行参数、内存大小、根文件系统位置
  - 内核入口地址：直接跳转到该地址
- **bootloader如何支持多种不同的启动设备**
  - 编译时，通过配置宏将不同设备的驱动编译进去
  - 运行时，通过检测启动引脚电平，在初始化代码中决定调用哪个设备的初始化函数和加载函数。


#### bootloader的基本流程
  - bootloader的启动流程是分阶段的
    - 阶段一：片上ROM bootloader（BL0）
      这是芯片内部rom中固化的代码，用户无法修改
      这部分的工作内容是：
      1. 初始化最关键的最小系统（关闭看门狗、设置栈、禁用中断、初始化时钟和存储器控制器等）
      2. 检测启动设备（根据boot引脚电平，决定从哪个设备（如flash、usb等）加载下一个阶段代码）
      3. 加载下一阶段代码（从启动阶段读取一小段代码到芯片的SRAM中）
      4. 跳转（跳转到SRAM中的BL1开始执行），进行下一个阶段
    - 阶段二：一级bootloader（在SRAM中运行）
      这部分的工作内容是：
      1. 进一步初始化硬件（初始化更复杂的外设，如DDR内存， 因为第一二阶段都在sram中运行，空间有限，而DDR容量大，必须初始化DDR后才能加载更大的程序）  
      2. 准备环境，从存储设备中将完整的二级bootloader代码加载到已经初始化好的DDR内存中，然后跳转到DDR中，进行下一阶段
    -  阶段三：二级bootloader（在DDR中运行）
        这是功能完整的bootloader，常见的就是u-boot
        这部分的工作内容是：
        1. 初始化所有剩余外设（如usb、显示、 网络等）
        2. 提供交互界面（提供一个命令行界面，允许开发者中断启动过程，进行手动配置，更新固件等）
        3. 加载操作系统内核（从存储设备将内核映像和设备树文件读入内存，将内核映像解压到指定位置）
        4. 设置启动参数（为内核设置好启动参数，告诉内核根文件系统在哪里）
        5. 跳转到内核（最终跳转到内核的入口地址，将控制权彻底交给操作系统）

#### 以X2100为例 bootloader流程总结
1. 上电/复位：芯片复位，从固定地址开始执行BootROM（BL0）代码
2. BL0（ROM code）：
   - 读取boot_sel[2:0]引脚，确定启动设备（flash、usb等）。
   - 初始化该设备的基本控制器（如SFC时钟等）
   - 从设备加载SPL到内部SRAM
   - 验签，跳转到SRAM
3. BL1（SPL）：
   - 用c语言进行更复杂的初始化 特别是DDR
   - 将完整的U-Boot从存储设备加载到DDR内存
   - 跳转的DDR中的U-Boot
4. U-Boot
   - 初始化所有需要的外设
   - 提供控制台，等待或自动执行启动命令
   - 从存储设备加载Linux内核和设备树到内存
   - 执行bootm命令，跳转到内核，系统启动完成 

#### bootloader的具体实现
- 链接脚本
  - 告诉编译器代码、数据、栈应该放在内存的那个位置
  - SPL：会被链接到SRAM的地址
  - U-Boot：会被链接到DDR的地址
- 启动头/向量表
  - CPU 上电后首先执行的地方，通常第一条指令是设置异常向量表
- 关键初始化代码（汇编和C）
  - 关闭看门狗（防止系统重启）
  - 设置栈指针（C语言函数调用需要用栈）
  - 初始化系统时钟（配置PLL，提升CPU、DDR等工作效率）
  - 初始化内存控制器（配置DDR时序参数）
  - 代码重定位（将自身从flash复制到DDR中运行，以提升速度）
  - 清BSS段（将未初始化的全局变量所在区域清0）
- 设备驱动
  - bootloader需要驱动各种存储设备来读取内核（如SPI Flash驱动、usb驱动）
- 命令行交互
  - 实现一个简单的命令行解析器，提供（printenv、setenv、saveenv等命令）
- 内核加载机制
  - 实现识别内核格式、解压、传递设备树和启动参数的逻辑





---
#### 交叉编译
* 什么是交叉编译？
  * 将源代码编译为在不同硬件架构或操作系统上运行的可执行文件的过程
  * 程序在pc上编辑、编译 最终在开发板上运行 程序的编译和运行不在同一台机器上